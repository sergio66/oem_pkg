OEM : how to set up Rodgers
---------------------------
07/29/2013 : added Andy Tangborn's covariance matrix infp

07/09/2013 : removed driver.oem.othergases
    othergases     : -1 means you only have Q1(z) ; else you can have 
                           Q2(z),Q3(z), ... QN(z) 
                      [see vars_jacobian.txt : numQlays]


driver.oem     
                        nloop: 10
                        rates: -1
                      klayers: '/asl/packages/klayersV205/BinV201/klayers_airs'
                        sarta: '/asl/packages/sartaV108_PGEv6/Bin/sarta_airs_PGEv6_postNov2003'
                   headstruct: 'test_prof_headstruct.mat'
                   profstruct: 'test_prof_profstruct.mat'
                        dofit: 1
                 cov_filename: 'cov_lls.mat'
         spectralcov_filename: '../MakeERA_ratespectra/cov_spectra_yy_2009_latbin_02.mat'
             apriori_filename: 'apriori_zero'
    adjust_spectral_errorbars: 1.0000e-03
                       lambda: 0.1000
                    diag_only: 0
                   lambda_qst: [1.0000e-03 1.0000e-03 1.0000e-03 1.0000e-03 1.0000e-03 1.0000e-03]
                    lambda_Q1: 0.1000
                  lambda_temp: 1.0000e-03
                  sarta_error: 0
    regularizationVScovariances: 'C'
                          sigma: [1x1 struct]

    nloop          : default = 1; how many times you want to iterate the soln to cost fcn
    rates          : default = -1 since code was designed for spectral rates
                               +1 since may as well have code fit "regular" observed spectra
    klayers/sarta  : if rates = +1, need to know which sarta/klayers executables to run
    headstruct/profstruct : if rates = +1, need to have default [h,[],p,[]] to write to rtp files,
                            so you can run sarta

    dofit          : 0 for only do linear least squares or (+1) LLS and OEM

    oem.sarta_error: one unique number (for all 2378 or 8642 chans) for SARTA 
                     ForwardModel error estimate used in rodgers.m

    spectralcov_filename : if this is left as "dne" then not used
                           else has the 2378x2378 spectral covariance matrix, 
                           which is normalized by ncerrors
    adjust_spectral_errorbars : one scalar number with which to multiply ncerrors, 
                               so you can scale the spectral uncertainties
                               (default = 1)

    cov_filename : has the 200x200 parameter covariance in a matrix "cov"
                 : this could be diagnol, block diagnol, L0/L1, whatever you want; 
                   it can be further manipulated (see below)
    apriori_filename : has "apriori" which is the 200x1 apriori estimates of the 
                       parameters to be fitted

    regularizationVScovariances: 'R' or 'r' to use above regularization
                               : 'C' or 'c' to use Andy Tangborns covariance, see sigma below
   driver.oem.sigma contaiuns the GEOPHYSICAL std deviations to use
     temp_strat_VALUE: 4
    temp_strat_TOPLAY: 1
    temp_strat_BOTLAY: 49

      temp_trop_VALUE: 0.5000
     temp_trop_TOPLAY: 50
     temp_trop_BOTLAY: 97

      hum_strat_VALUE: 1.5000
     hum_strat_TOPLAY: 1
     hum_strat_BOTLAY: 49

       hum_trop_VALUE: 1
      hum_trop_TOPLAY: 50
      hum_trop_BOTLAY: 97

                  l_c: 2.4000             = length correlation (in terms of LEVELS)

                  qst: [4 1 4 1 1 1]      = for QST


%%%%%%%%%%%%%%%%%%%%%%%%%
WOW
   lambda,diag_only,lambda_qst,lambda_Q1,lambda_temp 
   allow you to further manipulate "cov"

     a) diag_only : r ---> r * driver.oem.lambda (default 0 or false)
     b) lambda_qst : 
       if ONE number, then 
         r(driver.jacobian.iqst,driver.jacobian.iqst) --> r(driver.jacobian.iqst,driver.jacobian.iqst) * river.oem.lambda_qst
       if eg 6 numbers and there are 6 QST jacs then make this a diagnol block
         r(driver.jacobian.iqst,driver.jacobian.iqst)     = r(driver.jacobian.iqst,driver.jacobian.iqst) .* diag(driver.oem.lambda_qst);
       if eg 7 numbers and there are 6 QST jacs then can individualize the relaxations
         r(driver.jacobian.iqst,driver.jacobian.iqst)     = r(driver.jacobian.iqst,driver.jacobian.iqst) .* diag(driver.oem.lambda_qst);
     lambda_QX
       if ONE number, then 
         r(driver.jacobian.iQX,driver.jacobian.iQX) --> r(driver.jacobian.iQX,driver.jacobian.iQX) * river.oem.lambda_QX
       if eg 6 numbers and there are 6 QST jacs then make this a diagnol block
         r(driver.jacobian.iQX,driver.jacobian.iQX)     = r(driver.jacobian.iQX,driver.jacobian.iQX) .* diag(driver.oem.lambda_QX);
       if eg 7 numbers and there are 6 QST jacs then can individualize the relaxations
         r(driver.jacobian.iQX,driver.jacobian.iQX)     = r(driver.jacobian.iQX,driver.jacobian.iQX) .* diag(driver.oem.lambda_QX);
     lambda_QTemp
       if ONE number, then 
         r(driver.jacobian.temp,driver.jacobian.temp) --> r(driver.jacobian.temp,driver.jacobian.temp) * river.oem.lambda_QTemp
       if eg 6 numbers and there are 6 QST jacs then make this a diagnol block
         r(driver.jacobian.temp,driver.jacobian.temp)     = r(driver.jacobian.temp,driver.jacobian.temp) .* diag(driver.oem.lambda_QTemp);
       if eg 7 numbers and there are 6 QST jacs then can individualize the relaxations
         r(driver.jacobian.temp,driver.jacobian.temp)     = r(driver.jacobian.temp,driver.jacobian.temp) .* diag(driver.oem.lambda_QTemp);

%%%%%%%%%%%%%%%%%%%%%%%%%!!!!!!!!!!!!
      then for T,Q1,Q2 .. QN
        r(ti(i),ti(i)) = r(ti(i),ti(i)) + driver.oem.lambda;

WOW
